{"id":"73920","content":"package com.microsoft.migration.assets.worker.service;\r\n\r\nimport com.microsoft.migration.assets.worker.model.ImageProcessingMessage;\r\nimport com.microsoft.migration.assets.worker.util.StorageUtil;\r\nimport com.rabbitmq.client.Channel;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\r\nimport org.springframework.amqp.support.AmqpHeaders;\r\nimport org.springframework.messaging.handler.annotation.Header;\r\n\r\nimport javax.imageio.ImageIO;\r\nimport java.awt.Graphics2D;\r\nimport java.awt.RenderingHints;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\n\r\nimport static com.microsoft.migration.assets.worker.config.RabbitConfig.IMAGE_PROCESSING_QUEUE;\r\n\r\n@Slf4j\r\npublic abstract class AbstractFileProcessingService implements FileProcessor {\r\n\r\n    @RabbitListener(queues = IMAGE_PROCESSING_QUEUE)\r\n    public void processImage(final ImageProcessingMessage message, \r\n                           Channel channel, \r\n                           @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) {\r\n        boolean processingSuccess = false;\r\n        Path tempDir = null;\r\n        Path originalFile = null;\r\n        Path thumbnailFile = null;\r\n\r\n        try {\r\n            log.info(\"Processing image: {}\", message.getKey());\r\n\r\n            tempDir = Files.createTempDirectory(\"image-processing\");\r\n            originalFile = tempDir.resolve(\"original\" + StorageUtil.getExtension(message.getKey()));\r\n            thumbnailFile = tempDir.resolve(\"thumbnail\" + StorageUtil.getExtension(message.getKey()));\r\n\r\n            // Only process if message matches our storage type\r\n            if (message.getStorageType().equals(getStorageType())) {\r\n                // Download original file\r\n                downloadOriginal(message.getKey(), originalFile);\r\n\r\n                // Generate thumbnail\r\n                generateThumbnail(originalFile, thumbnailFile);\r\n\r\n                // Upload thumbnail\r\n                String thumbnailKey = StorageUtil.getThumbnailKey(message.getKey());\r\n                uploadThumbnail(thumbnailFile, thumbnailKey, message.getContentType());\r\n\r\n                log.info(\"Successfully processed image: {}\", message.getKey());\r\n\r\n                // Mark processing as successful\r\n                processingSuccess = true;\r\n            } else {\r\n                log.debug(\"Skipping message with storage type: {} (we handle {})\",\r\n                    message.getStorageType(), getStorageType());\r\n                // This is not an error, just not for this service, so we can acknowledge\r\n                processingSuccess = true;\r\n            }\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to process image: \" + message.getKey(), e);\r\n        } finally {\r\n            try {\r\n                // Cleanup temporary files\r\n                if (originalFile != null) {\r\n                    Files.deleteIfExists(originalFile);\r\n                }\r\n                if (thumbnailFile != null) {\r\n                    Files.deleteIfExists(thumbnailFile);\r\n                }\r\n                if (tempDir != null) {\r\n                    Files.deleteIfExists(tempDir);\r\n                }\r\n\r\n                if (processingSuccess) {\r\n                    // Acknowledge the message if processing was successful\r\n                    channel.basicAck(deliveryTag, false);\r\n                    log.debug(\"Message acknowledged for: {}\", message.getKey());\r\n                } else {\r\n                    // Reject the message with requeue=false to trigger dead letter exchange\r\n                    // This will route the message to the retry queue with delay\r\n                    channel.basicNack(deliveryTag, false, false);\r\n                    log.debug(\"Message rejected and sent to dead letter exchange for delayed retry: {}\", message.getKey());\r\n                }\r\n            } catch (IOException e) {\r\n                log.error(\"Error handling RabbitMQ acknowledgment for: {}\", message.getKey(), e);\r\n            }\r\n        }\r\n    }\r\n    \r\n    protected abstract String generateUrl(String key);\r\n\r\n    protected void generateThumbnail(Path input, Path output) throws IOException {\r\n        log.info(\"Generating thumbnail for: {}\", input);\r\n\r\n        // Read the original image\r\n        BufferedImage originalImage = ImageIO.read(input.toFile());\r\n        if (originalImage == null) {\r\n            throw new IOException(\"Could not read image file: \" + input);\r\n        }\r\n\r\n        int originalWidth = originalImage.getWidth();\r\n        int originalHeight = originalImage.getHeight();\r\n\r\n        // Calculate thumbnail dimensions while preserving aspect ratio\r\n        // Increased size significantly for better clarity (600px max dimension)\r\n        int maxDimension = 600;\r\n        int thumbnailWidth, thumbnailHeight;\r\n        \r\n        double aspectRatio = (double) originalWidth / originalHeight;\r\n\r\n        if (originalWidth > originalHeight) {\r\n            thumbnailWidth = maxDimension;\r\n            thumbnailHeight = (int) (maxDimension / aspectRatio);\r\n        } else {\r\n            thumbnailHeight = maxDimension;\r\n            thumbnailWidth = (int) (maxDimension * aspectRatio);\r\n        }\r\n\r\n        // Multi-step scaling for higher quality\r\n        // This progressive scaling produces better results than single-step scaling\r\n        BufferedImage resultImage = progressiveScaling(originalImage, thumbnailWidth, thumbnailHeight);\r\n\r\n        // Sharpen the image to enhance details\r\n        resultImage = sharpenImage(resultImage);\r\n\r\n        // Determine the output format based on the file extension\r\n        String extension = StorageUtil.getExtension(output.toString());\r\n        if (extension.startsWith(\".\")) {\r\n            extension = extension.substring(1);\r\n        }\r\n        if (extension.isEmpty()) {\r\n            extension = \"jpg\"; // Default to jpg if no extension found\r\n        }\r\n\r\n        // Write the thumbnail with optimized settings for different formats\r\n        if (extension.equalsIgnoreCase(\"jpg\") || extension.equalsIgnoreCase(\"jpeg\")) {\r\n            // For JPEG, we need to set compression quality\r\n            javax.imageio.ImageWriter jpgWriter = javax.imageio.ImageIO.getImageWritersByFormatName(\"jpg\").next();\r\n            javax.imageio.ImageWriteParam jpgWriteParam = jpgWriter.getDefaultWriteParam();\r\n            jpgWriteParam.setCompressionMode(javax.imageio.ImageWriteParam.MODE_EXPLICIT);\r\n            // Higher compression quality (0.95 for maximum clarity)\r\n            jpgWriteParam.setCompressionQuality(0.95f);\r\n            \r\n            javax.imageio.IIOImage outputImage = new javax.imageio.IIOImage(resultImage, null, null);\r\n            javax.imageio.stream.ImageOutputStream outputStream = \r\n                javax.imageio.ImageIO.createImageOutputStream(output.toFile());\r\n            jpgWriter.setOutput(outputStream);\r\n            jpgWriter.write(null, outputImage, jpgWriteParam);\r\n            jpgWriter.dispose();\r\n            outputStream.close();\r\n        } else {\r\n            // For PNG, use compression level 0 (no compression) for best quality\r\n            javax.imageio.ImageWriteParam pngWriteParam = null;\r\n            if (extension.equalsIgnoreCase(\"png\")) {\r\n                javax.imageio.ImageWriter pngWriter = ImageIO.getImageWritersByFormatName(\"png\").next();\r\n                pngWriteParam = pngWriter.getDefaultWriteParam();\r\n                if (pngWriteParam.canWriteCompressed()) {\r\n                    pngWriteParam.setCompressionMode(javax.imageio.ImageWriteParam.MODE_EXPLICIT);\r\n                    pngWriteParam.setCompressionType(\"Deflate\");\r\n                    pngWriteParam.setCompressionQuality(0.0f); // 0 = best quality for PNG\r\n                    \r\n                    javax.imageio.IIOImage outputImage = new javax.imageio.IIOImage(resultImage, null, null);\r\n                    javax.imageio.stream.ImageOutputStream outputStream = \r\n                        javax.imageio.ImageIO.createImageOutputStream(output.toFile());\r\n                    pngWriter.setOutput(outputStream);\r\n                    pngWriter.write(null, outputImage, pngWriteParam);\r\n                    pngWriter.dispose();\r\n                    outputStream.close();\r\n                } else {\r\n                    ImageIO.write(resultImage, extension, output.toFile());\r\n                }\r\n            } else {\r\n                // For other formats, use regular write method\r\n                ImageIO.write(resultImage, extension, output.toFile());\r\n            }\r\n        }\r\n\r\n        log.info(\"Successfully generated thumbnail: {}\", output);\r\n    }\r\n    \r\n    /**\r\n     * Performs progressive scaling of the image for better quality.\r\n     * This method gradually scales down the image in multiple steps rather than all at once.\r\n     */\r\n    private BufferedImage progressiveScaling(BufferedImage source, int targetWidth, int targetHeight) {\r\n        // Current dimensions\r\n        int currentWidth = source.getWidth();\r\n        int currentHeight = source.getHeight();\r\n        \r\n        // Don't scale up images that are already smaller than target size\r\n        if (currentWidth <= targetWidth && currentHeight <= targetHeight) {\r\n            return source;\r\n        }\r\n        \r\n        // Use a multi-step approach for higher quality\r\n        BufferedImage result = source;\r\n        \r\n        // Scale down in multiple steps for better quality (not more than 50% each step)\r\n        while (currentWidth > targetWidth * 1.5 || currentHeight > targetHeight * 1.5) {\r\n            int newWidth = Math.max(currentWidth / 2, targetWidth);\r\n            int newHeight = Math.max(currentHeight / 2, targetHeight);\r\n            \r\n            result = scaleImage(result, newWidth, newHeight);\r\n            \r\n            currentWidth = newWidth;\r\n            currentHeight = newHeight;\r\n        }\r\n        \r\n        // Final scaling to exact target dimensions\r\n        if (currentWidth != targetWidth || currentHeight != targetHeight) {\r\n            result = scaleImage(result, targetWidth, targetHeight);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Scale an image to specific dimensions using high quality settings.\r\n     */\r\n    private BufferedImage scaleImage(BufferedImage source, int width, int height) {\r\n        // Create a new BufferedImage for the result\r\n        BufferedImage result;\r\n        \r\n        // Preserve transparency for images with alpha channel\r\n        if (source.getTransparency() != BufferedImage.OPAQUE) {\r\n            result = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\r\n        } else {\r\n            result = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n        }\r\n        \r\n        // Set up the rendering process with maximum quality settings\r\n        Graphics2D g2d = result.createGraphics();\r\n        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\r\n        g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\r\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\r\n        g2d.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);\r\n        g2d.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);\r\n        g2d.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);\r\n        g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);\r\n        \r\n        // Draw the scaled image\r\n        g2d.drawImage(source, 0, 0, width, height, null);\r\n        g2d.dispose();\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Apply a sharpening filter to enhance image clarity\r\n     */\r\n    private BufferedImage sharpenImage(BufferedImage image) {\r\n        float[] sharpenMatrix = {\r\n            0, -0.2f, 0,\r\n            -0.2f, 1.8f, -0.2f,\r\n            0, -0.2f, 0\r\n        };\r\n        \r\n        java.awt.image.Kernel kernel = new java.awt.image.Kernel(3, 3, sharpenMatrix);\r\n        java.awt.image.ConvolveOp convolveOp = new java.awt.image.ConvolveOp(\r\n            kernel, java.awt.image.ConvolveOp.EDGE_NO_OP, null);\r\n        \r\n        // Create a compatible destination image to avoid potential issues with some image types\r\n        BufferedImage output;\r\n        if (image.getTransparency() != BufferedImage.OPAQUE) {\r\n            output = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);\r\n        } else {\r\n            output = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB); \r\n        }\r\n        \r\n        // Apply the filter\r\n        return convolveOp.filter(image, output);\r\n    }\r\n}\r\n"}